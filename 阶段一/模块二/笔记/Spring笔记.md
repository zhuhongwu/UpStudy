1.IoC
	1.1 IOC和DI
	  IOC : 控制反转(一种设计思想)
	    IOC和DI描述的是一个事情，只是角度不同。
		ioc是对对象的生成以及管理。
		DI是对对象的注入的等


2.BeanFactory是Spring Ioc中顶层接口，是用来定义一些基本功能和基础规范的，ApplicationContext是BeanFactory的一个子接口，所以具备BeanFactory的全部功能。并且拥有更多功能。



3.依赖注入

 	3.1 set注入（配置文件 property+参数set方法）

​	3.2 构造器注入（配置文件construc-args+参数构造器）

​	3.3  注解自动装配
4.BeanFactory和FactoryBean	

| 类          | 区别                                                         |
| ----------- | ------------------------------------------------------------ |
| BeanFactory | 是ioc的具体实现，为IOC提供最基本的规范                       |
| FactoryBean | 为ioc提供更加丰富的bean的生成，通过装饰者模式和简单工厂模式。 |

4.AOP 在不改变原有代码的基础上增强横切逻辑。

**Spring在动态代理中的使用  jdk动态代理和cglib   jdk动态代理需要实现接口 cglib不需要  spring按照这个区别来做的选择。**

5.事务

事务的特性

A：原子性

C：一致性

I：隔离性

D：持久性

**事务隔离级别处理事务并发问题。**

不考虑隔离问题，可能出现以下几个问题。

1.脏读

场景：

事务1给员⼯涨⼯资2000，但是事务1尚未被提交，员⼯发起事务2查询⼯资，发现⼯资涨了2000
块钱，读到了事务1尚未提交的数据（脏读）  --理解：一个事务update，另一个事务查询时候读到了这个未提交的。

2.不可重复读（针对update操作）

场景：

员工A在事务1查询自己工资为1W，当前事务未提交；

财务人员在此时提交了给员工A的涨薪2K事务2；

员工A在事务1再次发起查询，查询到工资为1.2W，1W再也查询不到了。---出现了不可重复读

3.幻读（针对insert和delete操作）

场景：

员工A在事务1查询资为1W的人员为10个人，当前事务未提交；

财务人员在事务2提交了两个新入职的1w的员工的事务；

员工A在事务1再次发起查询，查询到工资为1W的人员为12个。---出现了幻读



其中不可重复读和幻读概念类似，只是针对的操作不一样。

事务隔离级别：



| Serializable（串行化）      | 避免了脏读，不可重复读，幻读                           | 1        |
| --------------------------- | ------------------------------------------------------ | -------- |
| Repeatable read（可重复读） | 避免了不可重复读，脏读，幻读有可能发生（对update加锁） | 2        |
| Read commited（读已提交）   | 避免了脏读，一定会出现不可重复读，和幻读               | 3        |
| Read uncommited（读未提交） | 三者均会出现                                           | 级别最低 |

